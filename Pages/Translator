
import React, { useState, useEffect, useRef } from "react";
import { base44 } from "@/api/base44Client";
import { Button } from "@/components/ui/button";
import { Download, Mic, MicOff, Settings, Moon, Sun, Sparkles } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";

import LanguageSelector from "../components/translator/LanguageSelector";
import CaptionDisplay from "../components/translator/CaptionDisplay";
import ControlPanel from "../components/translator/ControlPanel";
import ExportModal from "../components/translator/ExportModal";
import DraggableCaption from "../components/translator/DraggableCaption";

export default function Translator() {
  const [isListening, setIsListening] = useState(false);
  const [interimText, setInterimText] = useState("");
  const [finalText, setFinalText] = useState("");
  const [translatedText, setTranslatedText] = useState("");
  const [sourceLanguage, setSourceLanguage] = useState("en-US");
  const [targetLanguage, setTargetLanguage] = useState("es-ES"); // Changed default target language to include region
  const [captionHistory, setCaptionHistory] = useState([]);
  const [latency, setLatency] = useState(0);
  const [isTranslating, setIsTranslating] = useState(false);
  const [showExport, setShowExport] = useState(false);
  const [isDarkMode, setIsDarkMode] = useState(true);
  const [showSettings, setShowSettings] = useState(false);
  const [showDraggableCaption, setShowDraggableCaption] = useState(false);

  const recognitionRef = useRef(null);
  const translationTimerRef = useRef(null);
  const targetLanguageRef = useRef(targetLanguage); // Added ref for targetLanguage

  // Keep target language ref updated
  useEffect(() => {
    targetLanguageRef.current = targetLanguage;
  }, [targetLanguage]);

  useEffect(() => {
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
      alert("Speech recognition is not supported in this browser. Please use Chrome or Edge.");
      return;
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = sourceLanguage;

    recognition.onresult = async (event) => {
      let interim = "";
      let final = "";

      for (let i = event.resultIndex; i < event.results.length; i++) {
        const transcript = event.results[i][0].transcript;
        if (event.results[i].isFinal) {
          final += transcript + " ";
        } else {
          interim += transcript;
        }
      }

      if (interim) {
        setInterimText(interim);
        clearTimeout(translationTimerRef.current);
        translationTimerRef.current = setTimeout(() => {
          translateText(interim, false);
        }, 500);
      }

      if (final) {
        setFinalText(prev => prev + final);
        translateText(final, true);
      }
    };

    recognition.onerror = (event) => {
      console.error("Speech recognition error:", event.error);
      if (event.error === 'no-speech') {
        return;
      }
      setIsListening(false);
    };

    recognition.onend = () => {
      if (isListening) { // This `isListening` will be from the closure at the time the effect ran
        recognition.start();
      }
    };

    recognitionRef.current = recognition;

    return () => {
      if (recognitionRef.current) {
        recognitionRef.current.stop();
      }
    };
  }, [sourceLanguage, isListening]); // Added isListening to dependencies to ensure recognition re-initializes on state change

  const translateText = async (text, isFinal) => {
    if (!text.trim()) return;
    
    const startTime = Date.now();
    setIsTranslating(true);

    try {
      // Use the ref to get the current target language
      const currentTargetLang = targetLanguageRef.current;
      const sourceLangName = getLanguageName(sourceLanguage);
      const targetLangName = getLanguageName(currentTargetLang);

      // Enhanced prompt for LLM to ensure accurate translation and output format
      const prompt = `You are a professional translator. Translate the following text from ${sourceLangName} to ${targetLangName}. 
      
IMPORTANT: You MUST translate to ${targetLangName}. Do not translate to any other language.
Maintain natural flow and add proper punctuation. 
Only return the translated text in ${targetLangName}, nothing else.
      
Text to translate: "${text}"

Translated text in ${targetLangName}:`;

      const result = await base44.integrations.Core.InvokeLLM({
        prompt: prompt,
        add_context_from_internet: false,
      });

      const translated = result.trim();
      setTranslatedText(translated);
      
      const endTime = Date.now();
      setLatency(endTime - startTime);

      if (isFinal) {
        setCaptionHistory(prev => [...prev, {
          timestamp: new Date(),
          original: text,
          translated: translated,
        }]);
        setInterimText("");
      }
    } catch (error) {
      console.error("Translation error:", error);
    } finally {
      setIsTranslating(false);
    }
  };

  const getLanguageName = (code) => {
    // Updated language codes to include region for better specificity
    const languages = {
      "en-US": "English",
      "es-ES": "Spanish",
      "fr-FR": "French",
      "de-DE": "German",
      "it-IT": "Italian",
      "pt-PT": "Portuguese",
      "ru-RU": "Russian",
      "ja-JP": "Japanese",
      "ko-KR": "Korean",
      "zh-CN": "Chinese (Simplified)",
      "ar-SA": "Arabic",
      "hi-IN": "Hindi",
      "nl-NL": "Dutch",
      "pl-PL": "Polish",
      "tr-TR": "Turkish",
    };
    return languages[code] || code;
  };

  const toggleListening = () => {
    if (isListening) {
      recognitionRef.current?.stop();
      setIsListening(false);
      setShowDraggableCaption(false);
    } else {
      recognitionRef.current?.start();
      setIsListening(true);
      setFinalText("");
      setTranslatedText("");
      setInterimText("");
    }
  };

  const handleExport = (format) => {
    if (format === 'txt') {
      const content = captionHistory
        .map(item => `${item.timestamp.toLocaleTimeString()}\n${item.original}\n${item.translated}\n\n`)
        .join('');
      
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `translation-${Date.now()}.txt`;
      a.click();
    } else if (format === 'srt') {
      const content = captionHistory
        .map((item, index) => {
          const start = new Date(item.timestamp);
          const end = new Date(start.getTime() + 3000);
          return `${index + 1}\n${formatSrtTime(start)} --> ${formatSrtTime(end)}\n${item.translated}\n\n`;
        })
        .join('');
      
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `translation-${Date.now()}.srt`;
      a.click();
    }
    setShowExport(false);
  };

  const formatSrtTime = (date) => {
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    const ms = String(date.getMilliseconds()).padStart(3, '0');
    return `${hours}:${minutes}:${seconds},${ms}`;
  };

  return (
    <div className={`min-h-screen relative overflow-hidden transition-all duration-700 ${
      isDarkMode 
        ? 'bg-gradient-to-br from-slate-950 via-purple-950 to-slate-950' 
        : 'bg-gradient-to-br from-slate-50 via-purple-50 to-blue-50'
    }`}>
      {/* Animated background orbs */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <motion.div
          animate={{
            scale: [1, 1.2, 1],
            opacity: [0.3, 0.5, 0.3],
          }}
          transition={{ duration: 8, repeat: Infinity }}
          className={`absolute top-1/4 -left-48 w-96 h-96 rounded-full blur-3xl ${
            isDarkMode ? 'bg-purple-600/30' : 'bg-purple-400/20'
          }`}
        />
        <motion.div
          animate={{
            scale: [1, 1.3, 1],
            opacity: [0.2, 0.4, 0.2],
          }}
          transition={{ duration: 10, repeat: Infinity }}
          className={`absolute bottom-1/4 -right-48 w-96 h-96 rounded-full blur-3xl ${
            isDarkMode ? 'bg-blue-600/30' : 'bg-blue-400/20'
          }`}
        />
        <motion.div
          animate={{
            scale: [1, 1.1, 1],
            opacity: [0.2, 0.3, 0.2],
          }}
          transition={{ duration: 12, repeat: Infinity }}
          className={`absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-96 h-96 rounded-full blur-3xl ${
            isDarkMode ? 'bg-pink-600/20' : 'bg-pink-400/15'
          }`}
        />
      </div>

      <div className="relative z-10 max-w-7xl mx-auto px-4 py-6 md:py-10">
        {/* Header */}
        <motion.div
          initial={{ opacity: 0, y: -30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6 }}
          className="flex flex-col md:flex-row justify-between items-center mb-8 md:mb-12 gap-4"
        >
          <div className="text-center md:text-left">
            <div className="flex items-center gap-3 justify-center md:justify-start mb-2">
              <motion.div
                animate={{
                  rotate: [0, 5, -5, 0],
                }}
                transition={{ duration: 2, repeat: Infinity }}
              >
                <Sparkles className={`w-8 h-8 ${
                  isDarkMode ? 'text-purple-400' : 'text-purple-600'
                }`} />
              </motion.div>
              <h1 className={`text-4xl md:text-5xl font-bold bg-gradient-to-r ${
                isDarkMode 
                  ? 'from-white via-purple-200 to-blue-200' 
                  : 'from-slate-900 via-purple-600 to-blue-600'
              } bg-clip-text text-transparent`}>
                LiveTranslate AI
              </h1>
            </div>
            <p className={`text-sm md:text-base ${
              isDarkMode ? 'text-purple-300/80' : 'text-purple-700/80'
            }`}>
              Real-time speech translation powered by AI
            </p>
          </div>
          
          <div className="flex gap-3">
            <motion.div whileHover={{ scale: 1.05 }} whileTap={{ scale: 0.95 }}>
              <Button
                variant="ghost"
                size="icon"
                onClick={() => setIsDarkMode(!isDarkMode)}
                className={`relative overflow-hidden rounded-2xl backdrop-blur-xl border ${
                  isDarkMode 
                    ? 'bg-white/5 border-white/10 text-white hover:bg-white/10' 
                    : 'bg-white/40 border-purple-200/50 text-slate-900 hover:bg-white/60'
                }`}
              >
                <AnimatePresence mode="wait">
                  {isDarkMode ? (
                    <motion.div
                      key="sun"
                      initial={{ rotate: -90, opacity: 0 }}
                      animate={{ rotate: 0, opacity: 1 }}
                      exit={{ rotate: 90, opacity: 0 }}
                      transition={{ duration: 0.3 }}
                    >
                      <Sun className="w-5 h-5" />
                    </motion.div>
                  ) : (
                    <motion.div
                      key="moon"
                      initial={{ rotate: 90, opacity: 0 }}
                      animate={{ rotate: 0, opacity: 1 }}
                      exit={{ rotate: -90, opacity: 0 }}
                      transition={{ duration: 0.3 }}
                    >
                      <Moon className="w-5 h-5" />
                    </motion.div>
                  )}
                </AnimatePresence>
              </Button>
            </motion.div>

            <motion.div whileHover={{ scale: 1.05 }} whileTap={{ scale: 0.95 }}>
              <Button
                variant="ghost"
                size="icon"
                onClick={() => setShowSettings(!showSettings)}
                className={`relative overflow-hidden rounded-2xl backdrop-blur-xl border ${
                  isDarkMode 
                    ? 'bg-white/5 border-white/10 text-white hover:bg-white/10' 
                    : 'bg-white/40 border-purple-200/50 text-slate-900 hover:bg-white/60'
                } ${showSettings ? 'ring-2 ring-purple-500/50' : ''}`}
              >
                <motion.div
                  animate={{ rotate: showSettings ? 180 : 0 }}
                  transition={{ duration: 0.3 }}
                >
                  <Settings className="w-5 h-5" />
                </motion.div>
              </Button>
            </motion.div>
          </div>
        </motion.div>

        {/* Language Selection */}
        <AnimatePresence>
          {showSettings && (
            <motion.div
              initial={{ opacity: 0, height: 0, marginBottom: 0 }}
              animate={{ opacity: 1, height: "auto", marginBottom: 32 }}
              exit={{ opacity: 0, height: 0, marginBottom: 0 }}
              transition={{ duration: 0.3 }}
            >
              <LanguageSelector
                sourceLanguage={sourceLanguage}
                targetLanguage={targetLanguage}
                onSourceChange={setSourceLanguage}
                onTargetChange={setTargetLanguage}
                isDarkMode={isDarkMode}
              />
            </motion.div>
          )}
        </AnimatePresence>

        {/* Control Panel */}
        <ControlPanel
          isListening={isListening}
          onToggleListening={toggleListening}
          onExport={() => setShowExport(true)}
          onToggleDraggable={() => setShowDraggableCaption(!showDraggableCaption)}
          latency={latency}
          isTranslating={isTranslating}
          isDarkMode={isDarkMode}
          hasHistory={captionHistory.length > 0}
          showDraggableCaption={showDraggableCaption}
        />

        {/* Caption Display */}
        <CaptionDisplay
          interimText={interimText}
          translatedText={translatedText}
          captionHistory={captionHistory}
          isDarkMode={isDarkMode}
          isListening={isListening}
        />

        {/* Draggable Caption Overlay */}
        <AnimatePresence>
          {showDraggableCaption && (
            <DraggableCaption
              translatedText={translatedText}
              interimText={interimText}
              isDarkMode={isDarkMode}
              onClose={() => setShowDraggableCaption(false)}
            />
          )}
        </AnimatePresence>

        {/* Export Modal */}
        <ExportModal
          isOpen={showExport}
          onClose={() => setShowExport(false)}
          onExport={handleExport}
          isDarkMode={isDarkMode}
        />
      </div>
    </div>
  );
}
